<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Managing your executable Java project with Gradle</title><!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Managing your executable Java project with Gradle" />
<meta name="author" content="Manthan Dave" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I’ve been using Gradle for a while now and have quite used to it. Most of my Java projects are web applications so all Gradle has to do is to build them. Once built, I can just plop the war file onto tomcat and it just works. However, when I’m trying something out, I just need a simple .java file which I manually compile with javac and then run it with java command. This works most of the time, except when I wanted to try out something complex, something that uses loads of external libaries. Something like this normally needs a dependency management system like Gradle. Using my normal Gradle configuration, I got it to build the project really easily, however running it was quite difficult." />
<meta property="og:description" content="I’ve been using Gradle for a while now and have quite used to it. Most of my Java projects are web applications so all Gradle has to do is to build them. Once built, I can just plop the war file onto tomcat and it just works. However, when I’m trying something out, I just need a simple .java file which I manually compile with javac and then run it with java command. This works most of the time, except when I wanted to try out something complex, something that uses loads of external libaries. Something like this normally needs a dependency management system like Gradle. Using my normal Gradle configuration, I got it to build the project really easily, however running it was quite difficult." />
<link rel="canonical" href="/www/2015/08/28/managing-your-executable-java-project-with-gradle/" />
<meta property="og:url" content="/www/2015/08/28/managing-your-executable-java-project-with-gradle/" />
<meta property="og:site_name" content="Manthan’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-08-28T19:51:16+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Managing your executable Java project with Gradle" />
<script type="application/ld+json">
{"description":"I’ve been using Gradle for a while now and have quite used to it. Most of my Java projects are web applications so all Gradle has to do is to build them. Once built, I can just plop the war file onto tomcat and it just works. However, when I’m trying something out, I just need a simple .java file which I manually compile with javac and then run it with java command. This works most of the time, except when I wanted to try out something complex, something that uses loads of external libaries. Something like this normally needs a dependency management system like Gradle. Using my normal Gradle configuration, I got it to build the project really easily, however running it was quite difficult.","url":"/www/2015/08/28/managing-your-executable-java-project-with-gradle/","@type":"BlogPosting","headline":"Managing your executable Java project with Gradle","dateModified":"2015-08-28T19:51:16+00:00","datePublished":"2015-08-28T19:51:16+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/www/2015/08/28/managing-your-executable-java-project-with-gradle/"},"author":{"@type":"Person","name":"Manthan Dave"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="/www/feed.xml" title="Manthan's Blog" /><link rel="shortcut icon" type="image/x-icon" href="/www/logo.png" />
  <link rel="stylesheet" href="/www/assets/css/main.css" />
</head><body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/www/">..</a><article>
  <p class="post-meta">
    <time datetime="2015-08-28 19:51:16 +0000">2015-08-28</time>
  </p>
  
  <h1>Managing your executable Java project with Gradle</h1>

  <p>I’ve been using Gradle for a while now and have quite used to it. Most of my Java projects are web applications so all Gradle has to do is to build them. Once built, I can just plop the war file onto tomcat and it just works. However, when I’m trying something out, I just need a simple .java file which I manually compile with <code>javac</code> and then run it with <code>java</code> command. This works most of the time, except when I wanted to try out something complex, something that uses loads of external libaries. Something like this normally needs a dependency management system like Gradle. Using my normal Gradle configuration, I got it to build the project really easily, however running it was quite difficult.<!--more--></p>

<p>The main difficulty came from classpath problems. When you are running a web application via tomcat, it usually takes care of all that stuff. However, when you’re doing it manually, YOU have to take care of it. Again, because this required manual effort, I started finding ways to achieve that via Gradle. After a couple of hours, I finally got it working with the following build.gradle file:</p>
<pre class="lang:groovy ">apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'application'

mainClassName = "com.mypackage.awesomeapp.Main"

dependencies {
compile 'org.apache.httpcomponents:httpclient:4.5'
}

run {
systemProperties System.getProperties()
println(systemProperties)
}
</pre>
<p>The two key things here are the <code>apply plugin: 'application'</code> and <code>mainClassName = "com.mypackage.awesomeapp.Main"</code> lines. As the statement suggests, the first one applies the application plugin, declaring your project as a standalone application. The second one tells Gradle what class is your main class. Gradle then sets this in the manifest file of the resulting jar file so that when executed, it knows what class to invoke first. Once you have the setup ready, execute:</p>

<p><code>gradle run</code></p>

<p>Feel free to give me a shout if you find better solution than this and I’ll make sure the article gets updated with proper credit. Enjoy!</p>

</article>
      </div>
    </main></body>
</html>