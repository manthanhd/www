<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Useful unix file editing commands</title><!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Useful unix file editing commands" />
<meta name="author" content="Manthan Dave" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Find and replace text matching a regular expression in a single file sed -E -i &#39;&#39; &#39;s/(something\\-[\\da-zA-Z]+)/ToReplace/g&#39; path/to/file.txt The above command searches for the (something\-[\da-zA-Z]+) regular expression and replaces it whole (because of the parenthesis which means to select the text matching the expression within) with ToReplace. The g in the end indicates that the operation will be applied to all matches in the file as supplied in path/to/file.txt argument. The -i parameter along with &#39;&#39; suggests the sed command to perform the edit on the file itself, without creating a new copy. Find and replace text matching a regular expression in files matching name find /base/directory -name &quot;*.txt&quot; -type f | xargs -n 1 sed -E -i &#39;&#39; &#39;s/hello/hi/g&#39; The above command finds file within /base/directory whose names match *.txt format. Later we combine the output of this with xargs which appends each line of output (path to each matching file) to the following sed command. The -n 1 argument to the xargs command tells it to supply each line of argument one by one to the sed command. Find and replace text matching a regular expression in files whose contents match a regular expression grep -rlE &#39;TextToFindInFiles&#39; $(find /base/directory -name &#39;*.txt&#39; -type f) | xargs -n 1 sed -E -i &#39;&#39; &#39;s/hi/hello/g&#39; In the above command we use the basic find command to get a list of files that we want to do the search in. Then we use grep to recursively find in those files. Now in the above command we don’t really need the -r flag for grep because the find command will list full paths to those files, but we would need it if we were doing find on a relative path instead (like .). The -l flag for grep here will only list the paths to the files that it found having the content TextToFindInFiles and not the actual matching contents like it usually prints. This list of the files is then outputted to the xargs command which then subsequently runs the sed command." />
<meta property="og:description" content="Find and replace text matching a regular expression in a single file sed -E -i &#39;&#39; &#39;s/(something\\-[\\da-zA-Z]+)/ToReplace/g&#39; path/to/file.txt The above command searches for the (something\-[\da-zA-Z]+) regular expression and replaces it whole (because of the parenthesis which means to select the text matching the expression within) with ToReplace. The g in the end indicates that the operation will be applied to all matches in the file as supplied in path/to/file.txt argument. The -i parameter along with &#39;&#39; suggests the sed command to perform the edit on the file itself, without creating a new copy. Find and replace text matching a regular expression in files matching name find /base/directory -name &quot;*.txt&quot; -type f | xargs -n 1 sed -E -i &#39;&#39; &#39;s/hello/hi/g&#39; The above command finds file within /base/directory whose names match *.txt format. Later we combine the output of this with xargs which appends each line of output (path to each matching file) to the following sed command. The -n 1 argument to the xargs command tells it to supply each line of argument one by one to the sed command. Find and replace text matching a regular expression in files whose contents match a regular expression grep -rlE &#39;TextToFindInFiles&#39; $(find /base/directory -name &#39;*.txt&#39; -type f) | xargs -n 1 sed -E -i &#39;&#39; &#39;s/hi/hello/g&#39; In the above command we use the basic find command to get a list of files that we want to do the search in. Then we use grep to recursively find in those files. Now in the above command we don’t really need the -r flag for grep because the find command will list full paths to those files, but we would need it if we were doing find on a relative path instead (like .). The -l flag for grep here will only list the paths to the files that it found having the content TextToFindInFiles and not the actual matching contents like it usually prints. This list of the files is then outputted to the xargs command which then subsequently runs the sed command." />
<link rel="canonical" href="/www/2018/06/27/useful-unix-file-editing-commands/" />
<meta property="og:url" content="/www/2018/06/27/useful-unix-file-editing-commands/" />
<meta property="og:site_name" content="Manthan’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-27T12:55:15+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Useful unix file editing commands" />
<script type="application/ld+json">
{"description":"Find and replace text matching a regular expression in a single file sed -E -i &#39;&#39; &#39;s/(something\\\\-[\\\\da-zA-Z]+)/ToReplace/g&#39; path/to/file.txt The above command searches for the (something\\-[\\da-zA-Z]+) regular expression and replaces it whole (because of the parenthesis which means to select the text matching the expression within) with ToReplace. The g in the end indicates that the operation will be applied to all matches in the file as supplied in path/to/file.txt argument. The -i parameter along with &#39;&#39; suggests the sed command to perform the edit on the file itself, without creating a new copy. Find and replace text matching a regular expression in files matching name find /base/directory -name &quot;*.txt&quot; -type f | xargs -n 1 sed -E -i &#39;&#39; &#39;s/hello/hi/g&#39; The above command finds file within /base/directory whose names match *.txt format. Later we combine the output of this with xargs which appends each line of output (path to each matching file) to the following sed command. The -n 1 argument to the xargs command tells it to supply each line of argument one by one to the sed command. Find and replace text matching a regular expression in files whose contents match a regular expression grep -rlE &#39;TextToFindInFiles&#39; $(find /base/directory -name &#39;*.txt&#39; -type f) | xargs -n 1 sed -E -i &#39;&#39; &#39;s/hi/hello/g&#39; In the above command we use the basic find command to get a list of files that we want to do the search in. Then we use grep to recursively find in those files. Now in the above command we don’t really need the -r flag for grep because the find command will list full paths to those files, but we would need it if we were doing find on a relative path instead (like .). The -l flag for grep here will only list the paths to the files that it found having the content TextToFindInFiles and not the actual matching contents like it usually prints. This list of the files is then outputted to the xargs command which then subsequently runs the sed command.","url":"/www/2018/06/27/useful-unix-file-editing-commands/","@type":"BlogPosting","headline":"Useful unix file editing commands","dateModified":"2018-06-27T12:55:15+00:00","datePublished":"2018-06-27T12:55:15+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/www/2018/06/27/useful-unix-file-editing-commands/"},"author":{"@type":"Person","name":"Manthan Dave"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="/www/feed.xml" title="Manthan's Blog" /><link rel="shortcut icon" type="image/x-icon" href="/www/logo.png" />
  <link rel="stylesheet" href="/www/assets/css/main.css" />
</head><body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/www/">..</a><article>
  <p class="post-meta">
    <time datetime="2018-06-27 12:55:15 +0000">2018-06-27</time>
  </p>
  
  <h1>Useful unix file editing commands</h1>

  <h4>Find and replace text matching a regular expression in a single file</h4>
<pre class="lang:sh decode:true">sed -E -i '' 's/(something\\-[\\da-zA-Z]+)/ToReplace/g' path/to/file.txt</pre>
<p>The above command searches for the <code>(something\-[\da-zA-Z]+)</code> regular expression and replaces it whole (because of the parenthesis which means to select the text matching the expression within) with <code>ToReplace</code>. The <code>g</code> in the end indicates that the operation will be applied to all matches in the file as supplied in <code>path/to/file.txt</code> argument. The <code>-i</code> parameter along with <code>''</code> suggests the <code>sed</code> command to perform the edit on the file itself, without creating a new copy.</p>
<h4>Find and replace text matching a regular expression in files matching name</h4>
<pre class="lang:sh decode:true">find /base/directory -name "*.txt" -type f | xargs -n 1 sed -E -i '' 's/hello/hi/g'</pre>
<p>The above command finds file within <code>/base/directory</code> whose names match <code>*.txt</code> format. Later we combine the output of this with <code>xargs</code> which appends each line of output (path to each matching file) to the following <code>sed</code> command. The <code>-n 1</code> argument to the <code>xargs</code> command tells it to supply each line of argument one by one to the <code>sed</code> command.</p>
<h4>Find and replace text matching a regular expression in files whose contents match a regular expression</h4>
<pre class="lang:sh decode:true">grep -rlE 'TextToFindInFiles' $(find /base/directory -name '*.txt' -type f) | xargs -n 1 sed -E -i '' 's/hi/hello/g'</pre>
<p>In the above command we use the basic <code>find</code> command to get a list of files that we want to do the search in. Then we use <code>grep</code> to recursively find in those files. Now in the above command we don’t really need the <code>-r</code> flag for grep because the <code>find</code> command will list full paths to those files, but we would need it if we were doing find on a relative path instead (like <code>.</code>). The <code>-l</code> flag for grep here will only list the paths to the files that it found having the content <code>TextToFindInFiles</code> and not the actual matching contents like it usually prints. This list of the files is then outputted to the <code>xargs</code> command which then subsequently runs the <code>sed</code> command.</p>

<p> </p>

</article>
      </div>
    </main></body>
</html>