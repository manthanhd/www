<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Simplifying management of forks with npm forkpool module</title><!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Simplifying management of forks with npm forkpool module" />
<meta name="author" content="Manthan Dave" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Backstory Recently, I&#39;ve been working on a project that does a lot of heavy weight image processing. In a nutshell, a user uploads an image and then the website does a whole load of processing on that image and returns with the results. Depending on the size of the image it could take a while for it to load the results. The websites does other stuff as well so the scenario where a few users are concurrently uploading images, waiting for response while a whole load of other set of users are navigating to other parts of the website is very real. The performance was respectable, however, I wanted more. After a couple of hours of investigating around the issue, I finally settled on using forks for handling this type of load. A fork is a process that is spun off of a parent process. In this case, when a user uploads an image on the website, the node server creates a fork that then does the image processing. Meanwhile, the parent process hooks into the &quot;exit&quot; callback of the forked process so that it knows when the forked process has exited. When this happens, the parent process returns the results to the user. Now, every node process, no matter how asynchronous, is single threaded. This means that it utilises at most a single core of your CPU. So the fact that the new fork powered architecture creates a fork process to handle the heavy image processing means lower load on the single node process. It also means that the load is spread evenly across cpu cores. However, here lies the problem. Every time a new customer arrives on the website and uploads a new image, the node server spins up a new process. So, if many customers arrive and upload large images which could take 10-15 seconds to load, it will spin up a new process for each of those customers. Since each process maps to roughly one CPU core, having too many processes doing CPU intensive things will start to slow down everything thats running on that machine. This means that they will slow down each other as they race to get as much CPU time as they can. This problem also has a simple solution. Limit the number of forks so that they do not exceed a certain number. This number will vary upon usage and circumstances but after doing some benchmarking, in my case, this was 3. This meant that my application should, at any given time run at most 3 forks (processes). In technical speak, this is called pooling of resources. The idea behind this is that you create a pool of fixed size and then take things in and out of pool. Translating this into what I needed to do with my fork problem, I needed a pool of size 3 to manage my forks so that it will allow me to put at most 3 things in it. If I tried to put more things in it, it should queue those things, wait for current things that are running in it to finish and then automatically start the queued things. I googled for some time, trying to find a good way to pool my forks. I found a couple of solutions but none were as elegant as I&#39;d like them to be. I did find some good ones but they either were deprecated or weren&#39;t being maintained anymore. So, I got my IDE ready and started programming what will be known as the forkpool module. Forkpool The module comprises of two basic things. Forkpool and Forklet . Forklet  is a definition of a fork instance. For example, if you wanted to fork a node module named worker.js , your forklet will comprise of three things. First being the location of the module, second being additional environment configuration needed to run the fork and third (optional) being the time within which the fork must complete its execution (if it doesn&#39;t, it gets killed). The third option of specifying timeout was the one I couldn&#39;t find available in any of the existing fork pools and hence decided to create it. So once you have a forklet , you can use the forkpool to create a fork. Upon creating the forkpool, you can define the size of the pool in its constructor. This value is the maximum number of forks you want running in parallel at any given time. Once you have a forkpool  and forklet  objects you can execute forks. If you execute more forks than the capacity, it will queue the rest of the forks up and execute them one by one as the running forks finish their execution. The module also comes with a event system comprised of a set of events. Every time something happens with the forks, a event is triggered. You can subscribe to events on a specific fork or to all forks across the entire pool. Working within the asynchronous architecture of node, this just made sense. There are various kinds of events that let you know what is happening to a fork. These are scheduled , started , timedout and exited . Event callbacks also come with additional contextual information that provide more information regarding that specific event. Checkout these links below for more information regarding the module: NPM, Github, Travis CI" />
<meta property="og:description" content="Backstory Recently, I&#39;ve been working on a project that does a lot of heavy weight image processing. In a nutshell, a user uploads an image and then the website does a whole load of processing on that image and returns with the results. Depending on the size of the image it could take a while for it to load the results. The websites does other stuff as well so the scenario where a few users are concurrently uploading images, waiting for response while a whole load of other set of users are navigating to other parts of the website is very real. The performance was respectable, however, I wanted more. After a couple of hours of investigating around the issue, I finally settled on using forks for handling this type of load. A fork is a process that is spun off of a parent process. In this case, when a user uploads an image on the website, the node server creates a fork that then does the image processing. Meanwhile, the parent process hooks into the &quot;exit&quot; callback of the forked process so that it knows when the forked process has exited. When this happens, the parent process returns the results to the user. Now, every node process, no matter how asynchronous, is single threaded. This means that it utilises at most a single core of your CPU. So the fact that the new fork powered architecture creates a fork process to handle the heavy image processing means lower load on the single node process. It also means that the load is spread evenly across cpu cores. However, here lies the problem. Every time a new customer arrives on the website and uploads a new image, the node server spins up a new process. So, if many customers arrive and upload large images which could take 10-15 seconds to load, it will spin up a new process for each of those customers. Since each process maps to roughly one CPU core, having too many processes doing CPU intensive things will start to slow down everything thats running on that machine. This means that they will slow down each other as they race to get as much CPU time as they can. This problem also has a simple solution. Limit the number of forks so that they do not exceed a certain number. This number will vary upon usage and circumstances but after doing some benchmarking, in my case, this was 3. This meant that my application should, at any given time run at most 3 forks (processes). In technical speak, this is called pooling of resources. The idea behind this is that you create a pool of fixed size and then take things in and out of pool. Translating this into what I needed to do with my fork problem, I needed a pool of size 3 to manage my forks so that it will allow me to put at most 3 things in it. If I tried to put more things in it, it should queue those things, wait for current things that are running in it to finish and then automatically start the queued things. I googled for some time, trying to find a good way to pool my forks. I found a couple of solutions but none were as elegant as I&#39;d like them to be. I did find some good ones but they either were deprecated or weren&#39;t being maintained anymore. So, I got my IDE ready and started programming what will be known as the forkpool module. Forkpool The module comprises of two basic things. Forkpool and Forklet . Forklet  is a definition of a fork instance. For example, if you wanted to fork a node module named worker.js , your forklet will comprise of three things. First being the location of the module, second being additional environment configuration needed to run the fork and third (optional) being the time within which the fork must complete its execution (if it doesn&#39;t, it gets killed). The third option of specifying timeout was the one I couldn&#39;t find available in any of the existing fork pools and hence decided to create it. So once you have a forklet , you can use the forkpool to create a fork. Upon creating the forkpool, you can define the size of the pool in its constructor. This value is the maximum number of forks you want running in parallel at any given time. Once you have a forkpool  and forklet  objects you can execute forks. If you execute more forks than the capacity, it will queue the rest of the forks up and execute them one by one as the running forks finish their execution. The module also comes with a event system comprised of a set of events. Every time something happens with the forks, a event is triggered. You can subscribe to events on a specific fork or to all forks across the entire pool. Working within the asynchronous architecture of node, this just made sense. There are various kinds of events that let you know what is happening to a fork. These are scheduled , started , timedout and exited . Event callbacks also come with additional contextual information that provide more information regarding that specific event. Checkout these links below for more information regarding the module: NPM, Github, Travis CI" />
<link rel="canonical" href="/www/2016/04/08/simplifying-management-of-forks-with-npm-forkpool-module/" />
<meta property="og:url" content="/www/2016/04/08/simplifying-management-of-forks-with-npm-forkpool-module/" />
<meta property="og:site_name" content="Manthan’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-04-08T17:23:58+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Simplifying management of forks with npm forkpool module" />
<script type="application/ld+json">
{"description":"Backstory Recently, I&#39;ve been working on a project that does a lot of heavy weight image processing. In a nutshell, a user uploads an image and then the website does a whole load of processing on that image and returns with the results. Depending on the size of the image it could take a while for it to load the results. The websites does other stuff as well so the scenario where a few users are concurrently uploading images, waiting for response while a whole load of other set of users are navigating to other parts of the website is very real. The performance was respectable, however, I wanted more. After a couple of hours of investigating around the issue, I finally settled on using forks for handling this type of load. A fork is a process that is spun off of a parent process. In this case, when a user uploads an image on the website, the node server creates a fork that then does the image processing. Meanwhile, the parent process hooks into the &quot;exit&quot; callback of the forked process so that it knows when the forked process has exited. When this happens, the parent process returns the results to the user. Now, every node process, no matter how asynchronous, is single threaded. This means that it utilises at most a single core of your CPU. So the fact that the new fork powered architecture creates a fork process to handle the heavy image processing means lower load on the single node process. It also means that the load is spread evenly across cpu cores. However, here lies the problem. Every time a new customer arrives on the website and uploads a new image, the node server spins up a new process. So, if many customers arrive and upload large images which could take 10-15 seconds to load, it will spin up a new process for each of those customers. Since each process maps to roughly one CPU core, having too many processes doing CPU intensive things will start to slow down everything thats running on that machine. This means that they will slow down each other as they race to get as much CPU time as they can. This problem also has a simple solution. Limit the number of forks so that they do not exceed a certain number. This number will vary upon usage and circumstances but after doing some benchmarking, in my case, this was 3. This meant that my application should, at any given time run at most 3 forks (processes). In technical speak, this is called pooling of resources. The idea behind this is that you create a pool of fixed size and then take things in and out of pool. Translating this into what I needed to do with my fork problem, I needed a pool of size 3 to manage my forks so that it will allow me to put at most 3 things in it. If I tried to put more things in it, it should queue those things, wait for current things that are running in it to finish and then automatically start the queued things. I googled for some time, trying to find a good way to pool my forks. I found a couple of solutions but none were as elegant as I&#39;d like them to be. I did find some good ones but they either were deprecated or weren&#39;t being maintained anymore. So, I got my IDE ready and started programming what will be known as the forkpool module. Forkpool The module comprises of two basic things. Forkpool and Forklet . Forklet  is a definition of a fork instance. For example, if you wanted to fork a node module named worker.js , your forklet will comprise of three things. First being the location of the module, second being additional environment configuration needed to run the fork and third (optional) being the time within which the fork must complete its execution (if it doesn&#39;t, it gets killed). The third option of specifying timeout was the one I couldn&#39;t find available in any of the existing fork pools and hence decided to create it. So once you have a forklet , you can use the forkpool to create a fork. Upon creating the forkpool, you can define the size of the pool in its constructor. This value is the maximum number of forks you want running in parallel at any given time. Once you have a forkpool  and forklet  objects you can execute forks. If you execute more forks than the capacity, it will queue the rest of the forks up and execute them one by one as the running forks finish their execution. The module also comes with a event system comprised of a set of events. Every time something happens with the forks, a event is triggered. You can subscribe to events on a specific fork or to all forks across the entire pool. Working within the asynchronous architecture of node, this just made sense. There are various kinds of events that let you know what is happening to a fork. These are scheduled , started , timedout and exited . Event callbacks also come with additional contextual information that provide more information regarding that specific event. Checkout these links below for more information regarding the module: NPM, Github, Travis CI","url":"/www/2016/04/08/simplifying-management-of-forks-with-npm-forkpool-module/","@type":"BlogPosting","headline":"Simplifying management of forks with npm forkpool module","dateModified":"2016-04-08T17:23:58+00:00","datePublished":"2016-04-08T17:23:58+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/www/2016/04/08/simplifying-management-of-forks-with-npm-forkpool-module/"},"author":{"@type":"Person","name":"Manthan Dave"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="/www/feed.xml" title="Manthan's Blog" /><link rel="shortcut icon" type="image/x-icon" href="/www/logo.png" />
  <link rel="stylesheet" href="/www/assets/css/main.css" />
</head><body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/www/">..</a><article>
  <p class="post-meta">
    <time datetime="2016-04-08 17:23:58 +0000">2016-04-08</time>
  </p>
  
  <h1>Simplifying management of forks with npm forkpool module</h1>

  <p style="text-align: justify;"><strong>Backstory</strong></p>
<p style="text-align: justify;">Recently, I've been working on a project that does a lot of heavy weight image processing. In a nutshell, a user uploads an image and then the website does a whole load of processing on that image and returns with the results. Depending on the size of the image it could take a while for it to load the results. The websites does other stuff as well so the scenario where a few users are concurrently uploading images, waiting for response while a whole load of other set of users are navigating to other parts of the website is very real. The performance was respectable, however, I wanted more.<!--more--></p>
<p style="text-align: justify;">After a couple of hours of investigating around the issue, I finally settled on using forks for handling this type of load. A fork is a process that is spun off of a parent process. In this case, when a user uploads an image on the website, the node server creates a fork that then does the image processing. Meanwhile, the parent process hooks into the "exit" callback of the forked process so that it knows when the forked process has exited. When this happens, the parent process returns the results to the user.</p>
<p style="text-align: justify;">Now, every node process, no matter how asynchronous, is single threaded. This means that it utilises at most a single core of your CPU. So the fact that the new fork powered architecture creates a fork process to handle the heavy image processing means lower load on the single node process. It also means that the load is spread evenly across cpu cores.</p>
<p style="text-align: justify;">However, here lies the problem. Every time a new customer arrives on the website and uploads a new image, the node server spins up a new process. So, if many customers arrive and upload large images which could take 10-15 seconds to load, it will spin up a new process for each of those customers. Since each process maps to roughly one CPU core, having too many processes doing CPU intensive things will start to slow down everything thats running on that machine. This means that they will slow down each other as they race to get as much CPU time as they can.</p>
<p style="text-align: justify;">This problem also has a simple solution. Limit the number of forks so that they do not exceed a certain number. This number will vary upon usage and circumstances but after doing some benchmarking, in my case, this was 3. This meant that my application should, at any given time run at most 3 forks (processes).</p>
<p style="text-align: justify;">In technical speak, this is called pooling of resources. The idea behind this is that you create a pool of fixed size and then take things in and out of pool. Translating this into what I needed to do with my fork problem, I needed a pool of size 3 to manage my forks so that it will allow me to put at most 3 things in it. If I tried to put more things in it, it should queue those things, wait for current things that are running in it to finish and then automatically start the queued things.</p>
<p style="text-align: justify;">I googled for some time, trying to find a good way to pool my forks. I found a couple of solutions but none were as elegant as I'd like them to be. I did find some good ones but they either were deprecated or weren't being maintained anymore. So, I got my IDE ready and started programming what will be known as the <a href="https://www.npmjs.com/package/forkpool" target="_blank">forkpool</a> module.</p>
<p style="text-align: justify;"><strong>Forkpool</strong></p>
<p style="text-align: justify;">The module comprises of two basic things. <span class="lang:default decode:true crayon-inline">Forkpool</span> and <span class="lang:default decode:true crayon-inline">Forklet</span> . <span class="lang:default decode:true crayon-inline ">Forklet</span>  is a definition of a fork instance. For example, if you wanted to fork a node module named <span class="lang:default decode:true crayon-inline ">worker.js</span> , your forklet will comprise of three things. First being the location of the module, second being additional environment configuration needed to run the fork and third (optional) being the time within which the fork must complete its execution (if it doesn't, it gets killed). The third option of specifying timeout was the one I couldn't find available in any of the existing fork pools and hence decided to create it.</p>
<p style="text-align: justify;">So once you have a <span class="lang:default decode:true crayon-inline ">forklet</span> , you can use the forkpool to create a fork. Upon creating the forkpool, you can define the size of the pool in its constructor. This value is the maximum number of forks you want running in parallel at any given time.</p>
<p style="text-align: justify;">Once you have a <span class="lang:default decode:true crayon-inline ">forkpool</span>  and <span class="lang:default decode:true crayon-inline ">forklet</span>  objects you can execute forks. If you execute more forks than the capacity, it will queue the rest of the forks up and execute them one by one as the running forks finish their execution.</p>
<p style="text-align: justify;">The module also comes with a event system comprised of a set of events. Every time something happens with the forks, a event is triggered. You can subscribe to events on a specific fork or to all forks across the entire pool. Working within the asynchronous architecture of node, this just made sense. There are various kinds of events that let you know what is happening to a fork. These are <span class="lang:default decode:true crayon-inline">scheduled</span> , <span class="lang:default decode:true crayon-inline">started</span> , <span class="lang:default decode:true crayon-inline">timedout</span> and <span class="lang:default decode:true crayon-inline ">exited</span> . Event callbacks also come with additional contextual information that provide more information regarding that specific event.</p>
<p style="text-align: justify;">Checkout these links below for more information regarding the module:</p>
<p><a href="https://www.npmjs.com/package/forkpool">NPM</a>, <a href="https://github.com/manthanhd/forkpool" target="_blank">Github</a>, <a href="https://travis-ci.org/manthanhd/forkpool" target="_blank">Travis CI</a></p>

</article>
      </div>
    </main></body>
</html>