<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Waiting for tomcat to start up in a script</title><!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Waiting for tomcat to start up in a script" />
<meta name="author" content="Manthan Dave" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="So here’s something that I have found that waits for tomcat to come up but rather than polling or a static time based wait, it uses FIFO pipeline to wait. function isTomcatUp { # Use FIFO pipeline to check catalina.out for server startup notification rather than # ping with an HTTP request. This was recommended by ForgeRock (Zoltan). FIFO=/tmp/notifytomcatfifo mkfifo &quot;${FIFO}&quot; || exit 1 { # run tail in the background so that the shell can # kill tail when notified that grep has exited tail -f $CATALINA_HOME/logs/catalina.out &amp; # remember tail&#39;s PID TAILPID=$! # wait for notification that grep has exited read foo &lt;${FIFO} # grep has exited, time to go kill &quot;${TAILPID}&quot; } | { grep -m 1 &quot;INFO: Server startup&quot; # notify the first pipeline stage that grep is done echo &gt;${FIFO} } # clean up rm &quot;${FIFO}&quot; } Drop this into a tomcat-util.sh file, make it executable and then source the file: chmod u+x tomcat-util.sh source tomcat-util.sh You’ll now have isTomcatUp available as a bash command." />
<meta property="og:description" content="So here’s something that I have found that waits for tomcat to come up but rather than polling or a static time based wait, it uses FIFO pipeline to wait. function isTomcatUp { # Use FIFO pipeline to check catalina.out for server startup notification rather than # ping with an HTTP request. This was recommended by ForgeRock (Zoltan). FIFO=/tmp/notifytomcatfifo mkfifo &quot;${FIFO}&quot; || exit 1 { # run tail in the background so that the shell can # kill tail when notified that grep has exited tail -f $CATALINA_HOME/logs/catalina.out &amp; # remember tail&#39;s PID TAILPID=$! # wait for notification that grep has exited read foo &lt;${FIFO} # grep has exited, time to go kill &quot;${TAILPID}&quot; } | { grep -m 1 &quot;INFO: Server startup&quot; # notify the first pipeline stage that grep is done echo &gt;${FIFO} } # clean up rm &quot;${FIFO}&quot; } Drop this into a tomcat-util.sh file, make it executable and then source the file: chmod u+x tomcat-util.sh source tomcat-util.sh You’ll now have isTomcatUp available as a bash command." />
<link rel="canonical" href="/www/2016/01/15/waiting-for-tomcat-to-start-up-in-a-script/" />
<meta property="og:url" content="/www/2016/01/15/waiting-for-tomcat-to-start-up-in-a-script/" />
<meta property="og:site_name" content="Manthan’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-01-15T13:49:16+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Waiting for tomcat to start up in a script" />
<script type="application/ld+json">
{"description":"So here’s something that I have found that waits for tomcat to come up but rather than polling or a static time based wait, it uses FIFO pipeline to wait. function isTomcatUp { # Use FIFO pipeline to check catalina.out for server startup notification rather than # ping with an HTTP request. This was recommended by ForgeRock (Zoltan). FIFO=/tmp/notifytomcatfifo mkfifo &quot;${FIFO}&quot; || exit 1 { # run tail in the background so that the shell can # kill tail when notified that grep has exited tail -f $CATALINA_HOME/logs/catalina.out &amp; # remember tail&#39;s PID TAILPID=$! # wait for notification that grep has exited read foo &lt;${FIFO} # grep has exited, time to go kill &quot;${TAILPID}&quot; } | { grep -m 1 &quot;INFO: Server startup&quot; # notify the first pipeline stage that grep is done echo &gt;${FIFO} } # clean up rm &quot;${FIFO}&quot; } Drop this into a tomcat-util.sh file, make it executable and then source the file: chmod u+x tomcat-util.sh source tomcat-util.sh You’ll now have isTomcatUp available as a bash command.","url":"/www/2016/01/15/waiting-for-tomcat-to-start-up-in-a-script/","@type":"BlogPosting","headline":"Waiting for tomcat to start up in a script","dateModified":"2016-01-15T13:49:16+00:00","datePublished":"2016-01-15T13:49:16+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/www/2016/01/15/waiting-for-tomcat-to-start-up-in-a-script/"},"author":{"@type":"Person","name":"Manthan Dave"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="/www/feed.xml" title="Manthan's Blog" /><link rel="shortcut icon" type="image/x-icon" href="/www/logo.png" />
  <link rel="stylesheet" href="/www/assets/css/main.css" />
</head><body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/www/">..</a><article>
  <p class="post-meta">
    <time datetime="2016-01-15 13:49:16 +0000">2016-01-15</time>
  </p>
  
  <h1>Waiting for tomcat to start up in a script</h1>

  <p>So here’s something that I have found that waits for tomcat to come up but rather than polling or a static time based wait, it uses FIFO pipeline to wait.</p>
<pre class="lang:sh decode:true">function isTomcatUp {
       
    # Use FIFO pipeline to check catalina.out for server startup notification rather than
    # ping with an HTTP request. This was recommended by ForgeRock (Zoltan).
   
    FIFO=/tmp/notifytomcatfifo
    mkfifo "${FIFO}" || exit 1
    {
        # run tail in the background so that the shell can
        # kill tail when notified that grep has exited
        tail -f $CATALINA_HOME/logs/catalina.out &amp;
        # remember tail's PID
        TAILPID=$!
        # wait for notification that grep has exited
        read foo &lt;${FIFO}
        # grep has exited, time to go
        kill "${TAILPID}"
    } | {
        grep -m 1 "INFO: Server startup"
        # notify the first pipeline stage that grep is done
        echo &gt;${FIFO}
    }
    # clean up
    rm "${FIFO}"
}</pre>
<p>Drop this into a tomcat-util.sh file, make it executable and then source the file:</p>
<pre class="lang:sh decode:true ">chmod u+x tomcat-util.sh
source tomcat-util.sh</pre>
<p>You’ll now have isTomcatUp available as a bash command.</p>

<p> </p>

</article>
      </div>
    </main></body>
</html>